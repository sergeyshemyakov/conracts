{"abi":[{"type":"function","name":"crossDomainMessageSender","inputs":[],"outputs":[{"name":"_sender","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"crossDomainMessageSource","inputs":[],"outputs":[{"name":"_source","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"messageNonce","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"relayMessage","inputs":[{"name":"_destination","type":"uint256","internalType":"uint256"},{"name":"_source","type":"uint256","internalType":"uint256"},{"name":"_nonce","type":"uint256","internalType":"uint256"},{"name":"_sender","type":"address","internalType":"address"},{"name":"_target","type":"address","internalType":"address"},{"name":"_message","type":"bytes","internalType":"bytes"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"sendMessage","inputs":[{"name":"_destination","type":"uint256","internalType":"uint256"},{"name":"_target","type":"address","internalType":"address"},{"name":"_message","type":"bytes","internalType":"bytes"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"successfulMessages","inputs":[{"name":"_msgHash","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"crossDomainMessageSender()":"38ffde18","crossDomainMessageSource()":"24794462","messageNonce()":"ecc70428","relayMessage(uint256,uint256,uint256,address,address,bytes)":"1ecd26f2","sendMessage(uint256,address,bytes)":"7056f41f","successfulMessages(bytes32)":"b1b1b209"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.26+commit.8a97fa7a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"crossDomainMessageSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crossDomainMessageSource\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_source\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_destination\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_source\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"relayMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_destination\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_msgHash\",\"type\":\"bytes32\"}],\"name\":\"successfulMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"crossDomainMessageSender()\":{\"returns\":{\"_sender\":\"Address of the sender of the current cross domain message.\"}},\"crossDomainMessageSource()\":{\"returns\":{\"_source\":\"Chain ID of the source of the current cross domain message.\"}},\"messageNonce()\":{\"returns\":{\"_0\":\"Nonce of the next message to be sent, with added message version.\"}},\"relayMessage(uint256,uint256,uint256,address,address,bytes)\":{\"params\":{\"_destination\":\"Chain ID of the destination chain.\",\"_message\":\"Message to send to the target.\",\"_nonce\":\"Nonce of the message being relayed.\",\"_sender\":\"Address of the user who sent the message.\",\"_source\":\"Chain ID of the source chain.\",\"_target\":\"Address that the message is targeted at.\"}},\"sendMessage(uint256,address,bytes)\":{\"params\":{\"_destination\":\"Chain ID of the destination chain.\",\"_message\":\"Message to trigger the target address with.\",\"_target\":\"Target contract or wallet address.\"}},\"successfulMessages(bytes32)\":{\"params\":{\"_msgHash\":\"message hash to check.\"},\"returns\":{\"_0\":\"Returns true if the message corresponding to the `_msgHash` was successfully relayed.\"}}},\"title\":\"IL2ToL2CrossDomainMessenger\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"crossDomainMessageSender()\":{\"notice\":\"Retrieves the sender of the current cross domain message.\"},\"crossDomainMessageSource()\":{\"notice\":\"Retrieves the source of the current cross domain message.\"},\"messageNonce()\":{\"notice\":\"Retrieves the next message nonce. Message version will be added to the upper two         bytes of the message nonce. Message version allows us to treat messages as having         different structures.\"},\"relayMessage(uint256,uint256,uint256,address,address,bytes)\":{\"notice\":\"Relays a message that was sent by the other CrossDomainMessenger contract. Can only         be executed via cross-chain call from the other messenger OR if the message was         already received once and is currently being replayed.\"},\"sendMessage(uint256,address,bytes)\":{\"notice\":\"Sends a message to some target address on a destination chain. Note that if the call         always reverts, then the message will be unrelayable, and any ETH sent will be         permanently locked. The same will occur if the target on the other chain is         considered unsafe (see the _isUnsafeTarget() function).\"},\"successfulMessages(bytes32)\":{\"notice\":\"Mapping of message hashes to boolean receipt values. Note that a message will only         be present in this mapping if it has successfully been relayed on this chain, and         can therefore not be relayed again.\"}},\"notice\":\"Interface for the L2ToL2CrossDomainMessenger contract.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/optimism/packages/contracts-bedrock/src/L2/interfaces/IL2ToL2CrossDomainMessenger.sol\":\"IL2ToL2CrossDomainMessenger\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":automate/=lib/optimism/packages/contracts-bedrock/lib/automate/contracts/\",\":ds-test/=lib/optimism/packages/contracts-bedrock/lib/solady/lib/ds-test/src/\",\":erc4626-tests/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-v5/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":kontrol-cheatcodes/=lib/optimism/packages/contracts-bedrock/lib/kontrol-cheatcodes/src/\",\":lib-keccak/=lib/optimism/packages/contracts-bedrock/lib/lib-keccak/contracts/\",\":openzeppelin-contracts-upgradeable/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts-v5/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-v5/\",\":openzeppelin-contracts/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts/\",\":optimism/=lib/optimism/\",\":prb-test/=lib/optimism/packages/contracts-bedrock/lib/automate/lib/prb-test/src/\",\":safe-contracts/=lib/optimism/packages/contracts-bedrock/lib/safe-contracts/contracts/\",\":solady/=lib/optimism/packages/contracts-bedrock/lib/solady/\",\":solmate/=lib/optimism/packages/contracts-bedrock/lib/solmate/src/\"]},\"sources\":{\"lib/optimism/packages/contracts-bedrock/src/L2/interfaces/IL2ToL2CrossDomainMessenger.sol\":{\"keccak256\":\"0xce9e3db5a5e2715673c14ceb630a2279528987f6d4476fc6cf900d32ecae555b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://37a7de56f5e46ccfd273d0076feb9038baf0885b68a4e94e97641562c9b01be1\",\"dweb:/ipfs/QmcvpN5i1AoEBfEUqam25jDYKXoBgqrScTSKyXDgfMLKdQ\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.26+commit.8a97fa7a"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"view","type":"function","name":"crossDomainMessageSender","outputs":[{"internalType":"address","name":"_sender","type":"address"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"crossDomainMessageSource","outputs":[{"internalType":"uint256","name":"_source","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"messageNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"uint256","name":"_destination","type":"uint256"},{"internalType":"uint256","name":"_source","type":"uint256"},{"internalType":"uint256","name":"_nonce","type":"uint256"},{"internalType":"address","name":"_sender","type":"address"},{"internalType":"address","name":"_target","type":"address"},{"internalType":"bytes","name":"_message","type":"bytes"}],"stateMutability":"payable","type":"function","name":"relayMessage"},{"inputs":[{"internalType":"uint256","name":"_destination","type":"uint256"},{"internalType":"address","name":"_target","type":"address"},{"internalType":"bytes","name":"_message","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"sendMessage"},{"inputs":[{"internalType":"bytes32","name":"_msgHash","type":"bytes32"}],"stateMutability":"view","type":"function","name":"successfulMessages","outputs":[{"internalType":"bool","name":"","type":"bool"}]}],"devdoc":{"kind":"dev","methods":{"crossDomainMessageSender()":{"returns":{"_sender":"Address of the sender of the current cross domain message."}},"crossDomainMessageSource()":{"returns":{"_source":"Chain ID of the source of the current cross domain message."}},"messageNonce()":{"returns":{"_0":"Nonce of the next message to be sent, with added message version."}},"relayMessage(uint256,uint256,uint256,address,address,bytes)":{"params":{"_destination":"Chain ID of the destination chain.","_message":"Message to send to the target.","_nonce":"Nonce of the message being relayed.","_sender":"Address of the user who sent the message.","_source":"Chain ID of the source chain.","_target":"Address that the message is targeted at."}},"sendMessage(uint256,address,bytes)":{"params":{"_destination":"Chain ID of the destination chain.","_message":"Message to trigger the target address with.","_target":"Target contract or wallet address."}},"successfulMessages(bytes32)":{"params":{"_msgHash":"message hash to check."},"returns":{"_0":"Returns true if the message corresponding to the `_msgHash` was successfully relayed."}}},"version":1},"userdoc":{"kind":"user","methods":{"crossDomainMessageSender()":{"notice":"Retrieves the sender of the current cross domain message."},"crossDomainMessageSource()":{"notice":"Retrieves the source of the current cross domain message."},"messageNonce()":{"notice":"Retrieves the next message nonce. Message version will be added to the upper two         bytes of the message nonce. Message version allows us to treat messages as having         different structures."},"relayMessage(uint256,uint256,uint256,address,address,bytes)":{"notice":"Relays a message that was sent by the other CrossDomainMessenger contract. Can only         be executed via cross-chain call from the other messenger OR if the message was         already received once and is currently being replayed."},"sendMessage(uint256,address,bytes)":{"notice":"Sends a message to some target address on a destination chain. Note that if the call         always reverts, then the message will be unrelayable, and any ETH sent will be         permanently locked. The same will occur if the target on the other chain is         considered unsafe (see the _isUnsafeTarget() function)."},"successfulMessages(bytes32)":{"notice":"Mapping of message hashes to boolean receipt values. Note that a message will only         be present in this mapping if it has successfully been relayed on this chain, and         can therefore not be relayed again."}},"version":1}},"settings":{"remappings":["automate/=lib/optimism/packages/contracts-bedrock/lib/automate/contracts/","ds-test/=lib/optimism/packages/contracts-bedrock/lib/solady/lib/ds-test/src/","erc4626-tests/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-v5/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","kontrol-cheatcodes/=lib/optimism/packages/contracts-bedrock/lib/kontrol-cheatcodes/src/","lib-keccak/=lib/optimism/packages/contracts-bedrock/lib/lib-keccak/contracts/","openzeppelin-contracts-upgradeable/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts-v5/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts-v5/","openzeppelin-contracts/=lib/optimism/packages/contracts-bedrock/lib/openzeppelin-contracts/","optimism/=lib/optimism/","prb-test/=lib/optimism/packages/contracts-bedrock/lib/automate/lib/prb-test/src/","safe-contracts/=lib/optimism/packages/contracts-bedrock/lib/safe-contracts/contracts/","solady/=lib/optimism/packages/contracts-bedrock/lib/solady/","solmate/=lib/optimism/packages/contracts-bedrock/lib/solmate/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/optimism/packages/contracts-bedrock/src/L2/interfaces/IL2ToL2CrossDomainMessenger.sol":"IL2ToL2CrossDomainMessenger"},"evmVersion":"paris","libraries":{}},"sources":{"lib/optimism/packages/contracts-bedrock/src/L2/interfaces/IL2ToL2CrossDomainMessenger.sol":{"keccak256":"0xce9e3db5a5e2715673c14ceb630a2279528987f6d4476fc6cf900d32ecae555b","urls":["bzz-raw://37a7de56f5e46ccfd273d0076feb9038baf0885b68a4e94e97641562c9b01be1","dweb:/ipfs/QmcvpN5i1AoEBfEUqam25jDYKXoBgqrScTSKyXDgfMLKdQ"],"license":"MIT"}},"version":1},"id":24}